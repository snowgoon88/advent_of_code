#+Title: What to do on Advent Calendars ?

* Library
** MyParser
parseLabelID :: String -> String -> Parser Int
parseList :: ListInfo -> String -> ListInfo *** in reverse order ***
parseLabelList :: String -> String -> ListInfo *** in reverse order ***
* Info : all soluces
https://www.reddit.com/r/adventofcode/comments/18h4ign/2023_day_12_part_2_how_to_approach_part_2/
https://github.com/jimflood/aoc2023/blob/main/src/Day12.hs
* TODO Advent23 : day 20
https://adventofcode.com/2023/day/13
https://hoogle.haskell.org/
* TODO Haskel plot 2D fig (lines, dots)
* Links
** gameof life, Comonad
https://javran.github.io/posts/2014-04-13-comonad-and-conways-game-of-life.html
https://javran.github.io/posts/2014-08-22-comonad-zipper-and-conways-game-of-life.html
https://www.youtube.com/watch?v=OqfHIujOvnE
https://ncatlab.org/nlab/files/Overton-ComonadsHaskell.pdf
https://github.com/ChrisPenner/conway/blob/master/src/Conway.hs
Control.Comonad
** Old Pixel Game Engine (C++)
https://github.com/OneLoneCoder/olcPixelGameEngine/wiki/Compiling-on-Linux
** sending even more money
https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet
https://www.schoolofhaskell.com/user/chowells79/even-more-money
** Hierarchical Free Monads
https://github.com/graninas/hierarchical-free-monads-the-most-developed-approach-in-haskell/blob/master/README.md
** Control Monad Error
https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error.html
** Recursive Schemes
https://blog.jle.im/entry/tries-with-recursion-schemes.html
** Hoogle
Data.Sequence
Linear.Matrix
Data.Map
Data.Vector
* Solved cases
** 2015
advent15_01: parenthesis like lisp go up, down. parse, zip
advent15_02: volume, surface of boxes, map, sum
advent15_03: path, parallel path in 4 direction
advent15_04: MD5, leading 0
advent15_05: parse String for doubles, triplets, etc
** 2020
https://blog.jle.im/entry/advent-of-code-2020.html
advent20_01: find n numbers in list that sums to n (knakpack)
advent20_02: parse 'int-int letter: string' and check some constraints on passwd
advent20_03: count trees when traverse down right (smart read grid)
advent20_04: parse and validate fields for passport (smart Refined, Barbies, Parser)
advent20_05: parse and "binary" decode, then "look" for absent value in list (foldl library for smart, Control.Foldl to make multiple fold in one pass !!)
advent20_06: union and intersections of Set of Char (smart NE.nonEmpty, fmap.fmap, foldr1)
advent20_07: bags inside bags, use Map and inverse the Map to find descendant or add values
advent20_07smart: smart use of fmap (and foldMapWithKey and toList) to invert, compute descendants or add values through Map and Set
advent20_08: virtual machine (adress, accumulator) using State. SMART: no State, but nice iterateMaybe
advent20_09: compute cumsum over sliding windows
advent20_10: sort sequence and compute combination under constraints (chain of adaptor). Smart is using kind of memoazind (DynProg ?) but no need in fact
advent20_11: game of life with custom neighbors, smart with Map of neighbors, MyGrid
advent20_12: move boat NESW and Forward, Right, Left. Linear.V2 and Circular Bounded Enum. (Smart uses a Semigroup of Direction to encode rotation of Directions)
advent20_13: syncronize prime numbers on their modulo (bus lines). SMPART = fold over natureal search of the problem !
advent20_14: exec prog with mask and set memory with value. Use List Monad to generate all address exhaustively. smart: uses the lense ifold' and ifoldM
advent20_15: gen sequence while memorizing (Map) last occurence time. Smart: optimize speed.
advent20_16: validate constraints intervales, determine valid rules (and, SMART, use monad list to search for constraintes like SEND + MORE + MONEY, see rambling)
advent20_17: game of life in 3D and 4D (SMART use V3/V4 as monad and applicative to determine generic neighbors)
advent20_18: parser for +, * and () with changing priorities (SMART Megaparsec)
advent20_19: parser for rules (AndOr), matching strings. (SMART -> recursive-scheme, hylomorphisme, anamorphisme, catamorphisme)
advent20_20: create big_image by transforming and tiling smaller images, detect pattern. Tedious with "image" storing and manipulation. (SMART a Group+Monoid with Orientation)
advent20_21: constraint satisfaction, (using StateT with [] Monad) over Alergen and Ingredient. List union and intersect. SMART: smaller and efficient writing.
advent20_22: recusive card battle game, with subgames. SMART: use Set instead of Map ?
advent20_23: HUGE loop on displacing cups => Vector.Mutable with ST Monad !! TODO in rambling.
advent20_24: follow path and cellular automata with Hex
advent20_25: public/secret keys (discrete logarithm)

** 2021
advent21_01: diff list and sliding windows.
advent21_02: add/combine forwrd/Up/down for submarine. SMART: can be written as a group (Monoid) operations.
advent21_03: filter list of binary according to majority bit
advent21_04: play bingo and determine win, last win. SMART: use IntSet (linear indices) rather than 2D Map. And "recursion schemes" of https://hackage.haskell.org/package/recursion-schemes-5.2.3
advent21_05: look for overlap of discrete lines (Map.unionsWith)
advent21_06: life and birth of Fish => Use Matrix=(Vector (Vector Int) product with Linear
advent21_07: minimize sum of arithmetic distance (fuel for submarine), quicksort but NO random pivot (some tries with Random)
advent21_08: 7-segment display: find wiring mapping using constraints. (SMART: compute all possible permutations, using Finite and Finitari and permutations)
advent21_09: heightMap, bassin of attraction (fold neighbors on Map). (SMART: use function "maybe", derive Map pointing to lower neighbors. Cannot use recursive-scheme as Set cannot be made a SetFunctor, nor Map)
advent21_10: balancing close/open parenthesis, score
advent21_11: propagate Flashes in 2D grid. (SMART: use unfoldr to generate infinite list, foldMap not really understood)
advent21_12: find all Path in Graph. Use List Monad.
advent21_13: "fold" 2D transparent paper, display grid (WARNING: increasing X first)
advent21_14: repeat insert character between two letters, polymerize.
advent21_15: aStar among riskMap, or repeated riskMap
advent21_16: parse embedded Packets, and recursively compute val or version

** 2023
advent23_01: parser numbers as digit or letters ("nine") in lines,
advent23_02: draw colored balls from bag, possible games, minimum number of balls
advent23_03: 2Dmap as lists, search numbers neigbors of symbols
advent23_04: cards with winning number and number drawn, can earn new cards, MyParser
advent23_05: mapping of numbers where mapping is given as ranges to ranges, MyParser
advent23_06: intervale computation, acceleration to get race time, MyParser
advent23_07: sort "poker" hands, with Joker, Data.List
advent23_08: list of graph node with label, synchronization of parallel cycles, prime diviser decomposition, Data.Map
advent23_09: recursive difference of lines of number to predict next element
advent23_10: 2D array using Data.Massiv.Array, Ix2 coord, follow path for cycles, inside area
advent23_11: hamming2D, map as list of list, zipped with coord
advent23_12: '?' pattern, combination, Data.Map, merging tree traversal cursor
advent23_13: find symetries in 2d grid, use Data.Massiv.Array.transpose, uncurry
advent23_14: twist plateform with stones, read grid2D, cache result Data.Map, find repeat cycle, Time
advent23_15: hash, Map, foldlWithKey
advent23_16: 2D grid reading, flow, path, Map to detect already used, chunks from MyParser
advent23_17: 2D grid readin, A*, Map, (pas optimal)
advent23_18: dir -> path, interior of Path.
advent23_19: chain Inf/Sup rules, intervale computation, trace
advent23_20: finite state machine, petri net, least common multiplier (lcm/ppmc), essai State

** 2024
advent24_01: distance between list, sort, group, Map
advent24_02: difference intra list, any, all, remove element from list
advent24_03: parse char by char for Mul, do, do not.
advent24_04: look for Word in 2D char grid, Map, Dir
advent24_05: sort, reorder lists succ/prec, repare liste right order, debug, detect/group empty lines
advent24_06: ricochet robot, put obstacle, grid 2D,
advent24_07: breadfirst search, op mul plus concat
advent24_08: read 2D grid elements as (Char, (Pos)) (zip), compute Vec from Pos, Set, antennae resonnance
advent24_09: defragment disk, block by block or using Block. Map, catMaybe :: filterFromJust
advent24_10: all paths between 0 and 9. modify Map using sublist of keys
advent24_11: divide stones, count Freq. sort, groupBy.
advent24_12: colorize regions 2D, find frontier (chaining corners), SHOULD Change DIR
advent24_13: machine with buttonA, buttonB. solve linear equation, group between empty lines
advent24_14: particule in toric world, mapToStr, criteria (minimise dist to centerline) pour avoir un "christmas tree"
advent24_15: push box size 1 ou 2, grid2D, niceWorld mapToStr, Dir is Int
advent24_16: short path, a*, astar, allpath (breadfirst), extract path from Map
advent24_17: run program microcode => CRC8 ??, find input to get an invariant program (search). not nice, should use "loop"
advent24_18: path through 2D map (aStar), then remap when obstacles are added
advent24_19: decompose long strings into subpatterns, depthfirstSearch, kind of breadhFirst search
advent24_20: only one possible path in labyrinthe2D, then can "fly over obst" for nb steps. (add kind of breadthFist but not needed), extract path,
advent24_21: n robots pushing buttons for code (numpad and arrowpad), cached version of Dynamic Programming and handcrafted optim !!! => TODO avec State Monad !!!!
advent24_22: pseudo random generator, memoazing/caching results, looking for patterns
advent24_23: subgraph and maximum clique (fully connected subgraph), Map of Set => Bron-Kerbosh algo
advent24_24: simulate AND, XOR and OR in graph of Gates, repare to get additioner (using Graphviz and list of digit defectueux)
advent24_25 : locks and keys as 7x5 grid2D, fit by comparing columns.


** 2025
advent25_01: apply rotation (foldl') to dial, count zero or passing before zero
advent25_02: find periods in number, between ranges
advent25_03: look for maximum sequence in list of numbers (bank of batteries, joltages)
advent25_04: map of neighbors to do some erosion (kind of game of life)
advent25_05: combine intervales and count nb inside
advent25_06: add/mult nbs vertically or horizontaly in a 2DGrid
advent25_07: split beams, dynamic programming ?
advent25_08: make graph by connecting closest nodes, sort descending order.
advent25_09: rect inside a Vert/hori perimeter
advent25_10: shortest path to light panel, integer linear programming then... TODO
advent25_11: count paths in graph => SMART traverse, evalState, recursive structure. TODO FlexibleContext
advent25_12: fits shapes on grid, but in fact just naively compare places and occupancy
